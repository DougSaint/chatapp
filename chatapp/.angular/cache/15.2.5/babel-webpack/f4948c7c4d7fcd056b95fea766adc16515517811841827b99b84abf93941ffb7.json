{"ast":null,"code":"import { io } from 'socket.io-client';\nimport { environment } from '../environments/environment';\nimport { Observable } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport class WebSocketService {\n  constructor() {\n    this.socket = io(environment.websocketUrl);\n  }\n  sendMessage(message) {\n    this.socket.emit('message', message);\n  }\n  onMessage() {\n    return new Observable(observer => {\n      this.socket.on('message', message => {\n        observer.next(message);\n      });\n    });\n  }\n  // Método para emitir eventos\n  emit(eventName, data) {\n    console.log('Emitting event:', eventName, data);\n    this.socket.emit(eventName, data);\n  }\n  // Método para ouvir eventos\n  on(eventName, callback) {\n    this.socket.on(eventName, callback);\n  }\n  // Método para desconectar do WebSocket\n  disconnect() {\n    this.socket.disconnect();\n  }\n  // Métodos adicionais para mensagens privadas\n  sendPrivateMessage(recipient, text) {\n    this.socket.emit('privateMessage', {\n      recipient,\n      text\n    });\n  }\n  onPrivateMessage() {\n    return new Observable(observer => {\n      this.socket.on('privateMessage', message => {\n        observer.next(message);\n      });\n    });\n  }\n}\nWebSocketService.ɵfac = function WebSocketService_Factory(t) {\n  return new (t || WebSocketService)();\n};\nWebSocketService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: WebSocketService,\n  factory: WebSocketService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"AACA,SAASA,EAAE,QAAgB,kBAAkB;AAC7C,SAASC,WAAW,QAAQ,6BAA6B;AACzD,SAASC,UAAU,QAAQ,MAAM;;AAKjC,OAAM,MAAOC,gBAAgB;EAG3BC;IACE,IAAI,CAACC,MAAM,GAAGL,EAAE,CAACC,WAAW,CAACK,YAAY,CAAC;EAC5C;EAEAC,WAAW,CAACC,OAAe;IACzB,IAAI,CAACH,MAAM,CAACI,IAAI,CAAC,SAAS,EAAED,OAAO,CAAC;EACtC;EAEAE,SAAS;IACP,OAAO,IAAIR,UAAU,CAAES,QAAQ,IAAI;MACjC,IAAI,CAACN,MAAM,CAACO,EAAE,CAAC,SAAS,EAAGJ,OAAe,IAAI;QAC5CG,QAAQ,CAACE,IAAI,CAACL,OAAO,CAAC;MACxB,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEA;EACAC,IAAI,CAACK,SAAiB,EAAEC,IAAS;IAC/BC,OAAO,CAACC,GAAG,CAAC,iBAAiB,EAAEH,SAAS,EAAEC,IAAI,CAAC;IAC/C,IAAI,CAACV,MAAM,CAACI,IAAI,CAACK,SAAS,EAAEC,IAAI,CAAC;EACnC;EAEA;EACAH,EAAE,CAACE,SAAiB,EAAEI,QAA6B;IACjD,IAAI,CAACb,MAAM,CAACO,EAAE,CAACE,SAAS,EAAEI,QAAQ,CAAC;EACrC;EAEA;EACAC,UAAU;IACR,IAAI,CAACd,MAAM,CAACc,UAAU,EAAE;EAC1B;EAEA;EAEAC,kBAAkB,CAACC,SAAiB,EAAEC,IAAY;IAChD,IAAI,CAACjB,MAAM,CAACI,IAAI,CAAC,gBAAgB,EAAE;MAAEY,SAAS;MAAEC;IAAI,CAAE,CAAC;EACzD;EAEAC,gBAAgB;IACd,OAAO,IAAIrB,UAAU,CAAES,QAAQ,IAAI;MACjC,IAAI,CAACN,MAAM,CAACO,EAAE,CAAC,gBAAgB,EAAGJ,OAAY,IAAI;QAChDG,QAAQ,CAACE,IAAI,CAACL,OAAO,CAAC;MACxB,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;;AA/CWL,gBAAgB;mBAAhBA,gBAAgB;AAAA;AAAhBA,gBAAgB;SAAhBA,gBAAgB;EAAAqB,SAAhBrB,gBAAgB;EAAAsB,YAFf;AAAM","names":["io","environment","Observable","WebSocketService","constructor","socket","websocketUrl","sendMessage","message","emit","onMessage","observer","on","next","eventName","data","console","log","callback","disconnect","sendPrivateMessage","recipient","text","onPrivateMessage","factory","providedIn"],"sourceRoot":"","sources":["/home/doug/Área de Trabalho/process/chatapp/src/app/web-socket.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { io, Socket } from 'socket.io-client';\nimport { environment } from '../environments/environment';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class WebSocketService {\n  private socket: Socket;\n\n  constructor() {\n    this.socket = io(environment.websocketUrl);\n  }\n\n  sendMessage(message: string): void {\n    this.socket.emit('message', message);\n  }\n\n  onMessage(): Observable<string> {\n    return new Observable((observer) => {\n      this.socket.on('message', (message: string) => {\n        observer.next(message);\n      });\n    });\n  }\n\n  // Método para emitir eventos\n  emit(eventName: string, data: any) {\n    console.log('Emitting event:', eventName, data);\n    this.socket.emit(eventName, data);\n  }\n\n  // Método para ouvir eventos\n  on(eventName: string, callback: (data: any) => void) {\n    this.socket.on(eventName, callback);\n  }\n\n  // Método para desconectar do WebSocket\n  disconnect() {\n    this.socket.disconnect();\n  }\n\n  // Métodos adicionais para mensagens privadas\n\n  sendPrivateMessage(recipient: string, text: string): void {\n    this.socket.emit('privateMessage', { recipient, text });\n  }\n\n  onPrivateMessage(): Observable<any> {\n    return new Observable((observer) => {\n      this.socket.on('privateMessage', (message: any) => {\n        observer.next(message);\n      });\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}